---
title: "Become a Superlearner! A Visual Guide & Introductory R Tutorial on Superlearning"
author: "Katherine Hoffman"
date: 2020-09-12T21:13:14-05:00
categories: ["R","statistics"]
draft: false
math: true
tags: ["R","SuperLearner","superlearning","stacking","stacked generalizations","ensemble learning","sl3","rstats"]
output: 
  html_document:
    toc: true
    toc_float: true
    smart: false
    print_df: paged
---

> Why use *one* machine learning algorithm when you could use all of them?! This post contains a step-by-step walkthrough of how to build a superlearner prediction algorithm in `R`.


<html>
   <head>
      <title>HTML Image as link</title>
   </head>
   <body>
         <img alt="cheatsheet" src="/img/Superlearning.jpg"  
         width=100%">
          <figcaption>***A Visual Guide...*** Over the winter, I read [*Targeted Learning*](https://www.springer.com/gp/book/9781441997814) by Mark van der Laan and Sherri Rose. This "visual guide" I made for *Chapter 3: Superlearning* by Rose, van der Laan, and Eric Polley is a condensed version of the following tutorial. It is available as an [8.5x11" pdf on Github](https://github.com/hoffmakl/CI-visual-guides/blob/master/visual-guides/Superlearner.pdf), should you wish to print it out for reference (or desk decor).</figcaption>
      </a>
   </body>
</html>


# Supercuts of superlearning

- **Superlearning** is a technique for prediction that involves **combining many individual statistical algorithms** (commonly called "data-adaptive" or "machine learning" algorithms) to **create a new, single prediction algorithm that is at least as good as any of the individual algorithms**.
  
- The superlearner algorithm "decides" how to combine, or weight, the individual algorithms based upon how well each one **minimizes a specified loss function**, for example, the mean squared error (MSE). This is done using cross-validation to avoid overfitting.
  
- The motivation for this type of "ensembling" is that **no single algorithm is always the best for all kinds of data**. For example, sometimes a penalized regression may be best, but in other situations a random forest may be superior. Even extreme gradient boosting is not *always* ideal! Superlearning allows you to use the beneficial information each algorithm provides to ultimately optimize your prediction capabilities.
  
- Superlearning is also called stacking, stacked generalizations, or weighted ensembling by different specializations within the realms of statistics and data science.
  
![](/img/spiderman_meme.jpg){width=42%}


# Superlearning, step by step

First I'll go through the algorithm one step at a time using a simulated data set. It is a modified version of Maya Peterson and Laura Balzar's [R Lab 3: Superlearning](https://www.ucbbiostat.com/labs) which you can try out if you want more practice.

<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 0: Load libraries, set seed, simulate data</h1></strong>
</body>
</html>

For simplicity I'll show the concept of superlearning using only four variables (AKA features or predictors) to predict a continuous outcome. Let's first simulate a continuous outcome, `y`, and four potential predictors, `x1`, `x2`, `x3`, and `x4`. 

```{r}
library(tidyverse, warn.conflicts = F)
library(kableExtra, warn.conflicts = F)
set.seed(7)
```

```{r}
n <- 5000
obs <- tibble::tibble(
  id = 1:n,
  x1 = rnorm(n),
  x2 = rbinom(n, 1, plogis(10*x1)),
  x3 = rbinom(n, 1, plogis(x1*x2 + .5*x2)),
  x4 = rnorm(n, mean=x1*x2, sd=.5*x3),
  y = x1 + x2 + x2*x3 + sin(x4)
)
kable(head(obs), digits=3, caption = "Simulated data set")
```



<html>
<body>
<h2 style="color:#c30a0a" > <strong>Step 1: Split data into K folds</h1></strong>
</body>
</html>

  ![](/img/sl_steps/step1.png){width=50%}
The superlearner algorithm relies on K-fold cross-validation (CV) to avoid overfitting. We will start this process by splitting the data into 10 folds. The easiest way to do this is by creating indices for each cross-validation fold.

```{r}
k <- 10 # 10 fold cv
cv_index <- sample(rep(1:k, each = n/k)) # indices for each fold, same length as our dataset `obs`
```


<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 2: Fit base learners for first CV-fold
</h1></strong>
</body>
</html>

  ![](/img/sl_steps/step2.png){width=50%}

Recall that in  K-fold CV, each fold serves as the validation set one time. In this first round of CV, we will train all of our base learners on all the cross-validation folds (k = 1,2,...,9) *except* for the very last one: `cv_index == 10`.

The individual algorithms or **base learners** that we'll use here are three linear regressions with differently specified parameters:

1. **Learner A**: $Y=\beta_0 + \beta_1 X_2 + \beta_2 X_4 + \epsilon$

2. **Learner B**: $Y=\beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_1 X_3 + \beta_4 sin(X_4)  + \epsilon$

3. **Learner C**: $Y=\beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_3 + \beta_4 X_1 X_2 + \beta_5 X_1 X_3 + \beta_6 X_2 X_3 + \beta_7 X_1 X_2 X_3  + \epsilon$

```{r}
cv_train_1 <- obs[-which(cv_index == 10),] # make a data set that contains all observations except those in k=1
fit_1a <- glm(y ~ x2 + x4, data=cv_train_1) # fit the first linear regression on that training data
fit_1b <- glm(y ~ x1 + x2 + x1*x3 + sin(x4), data=cv_train_1) # second LR fit on the training data
fit_1c <- glm(y ~ x1*x2*x3, data=cv_train_1) # and the third LR
```

I am *only* using the linear regressions so that code for running more complicated regressions does not take away from understanding the general superlearning algorithm.

Superlearning actually works best if you use a diverse set, or **superlearner library**, of base learners. For example, instead of three linear regressions, we could use a least absolute shrinkage estimator (LASSO), random forest, and multivariate adaptive splines (MARS). Any parametric or non-parametric supervised machine learning algorithm can be included as a base learner.



<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 3: Obtain predictions for first CV-fold
</h1></strong>
</body>
</html>

  ![](/img/sl_steps/step3.png){width=50%}

We can then get use our validation data, `cv_index == 10`, to obtain our first set of cross-validated predictions.

```{r}
cv_valid_1 <- obs[which(cv_index == 10),] # make a data set that only contains observations except in k=10
pred_1a <- predict(fit_1a, newdata = cv_valid_1) # use that data set as the validation for all the models in the SL library
pred_1b <- predict(fit_1b, newdata = cv_valid_1) 
pred_1c <- predict(fit_1c, newdata = cv_valid_1)
```

Since we have 5000 `obs`ervations, that gives us three vectors of length 500: a set of predictions for each of our Learners A, B, and C.

```{r}
length(pred_1a) # double check we only have n/k predictions ...we do :-)
knitr::kable(head(cbind(pred_1a, pred_1b, pred_1c)), digits= 2, caption = "First CV round of predictions") 
```


<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 4: Obtain CV predictions for entire data set
</h1></strong>
</body>
</html>

![](/img/sl_steps/step4.png){width=32%}

We'll want to get those predictions for *every* fold. So, using your favorite `for` loop, `apply` statement, or `map`ping function, fit the base learners and obtain predictions for each of them, so that there are 1000 predictions -- one for every point in `obs`ervations.

```{r}
cv_folds <- as.list(1:k)
names(cv_folds) <- paste0("fold",1:k)
cv_preds <-
  purrr::map_dfr(cv_folds, function(x){  # map_dfr loops through every fold (1:k) and binds the rows of the listed results together
  cv_train <- obs[-which(cv_index == x),]  # make a training data set that contains all data except fold k
  fit_a <- glm(y ~ x2 + x4, data=cv_train)  # fit all the base learners to that data
  fit_b <- glm(y ~ x1 + x2 + x1*x3 + sin(x4), data=cv_train)
  fit_c <- glm(y ~ x1*x2*x3, data=cv_train)
  cv_valid <- obs[which(cv_index == x),]  # make a validation data set that only contains data from fold k
  pred_a <- predict(fit_a, newdata = cv_valid)  # obtain predictions from all the base learners for that validation data
  pred_b <- predict(fit_b, newdata = cv_valid)
  pred_c <- predict(fit_c, newdata = cv_valid)
  return(tibble::tibble("obs_id" = cv_valid$id, "cv_fold" = x, pred_a, pred_b, pred_c))  # save the predictions and the ids of the observations in a data frame
})

cv_preds %>%
  arrange(obs_id) %>%
  head() %>%
  kable(digits=2, caption = "All CV predictions for all three base learners") 
```


<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 5: Choose and compute loss function of interest via metalearner
</h1></strong>
</body>
</html>


![](/img/sl_steps/step5.png){width=60%}

> This is the key step of the superlearner algorithm: we will use a new learner, a **metalearner**, to take information from all of the base learners and create that new algorithm.

Now that we have cross-validated predictions for every observation in the data set, we want to merge those CV predictions back into our main data set...

```{r}
obs_preds <- 
  full_join(obs, cv_preds, by=c("id" = "obs_id"))
```

...so that we can minimize a final loss function of interest between the true outcome and each CV prediction. This is how we're going to optimize our overall prediction algorithm: we want to make sure we're "losing the least" in the way we combine our base learners' predictions to ultimately make final predictions. We can do this efficiently by choosing a new learner, a metalearner, which reflects the final loss function of interest.

For simplicity, we'll use yet another linear regression as our metalearner. The metalearner *could* be a more complicated statistical learning algorithm (LASSO, random forest, etc.), and in fact the default in the `SuperLearner` package is actually non-negative least squares (NNLS). 

No matter what metalearner we choose, the predictors will always be the cross-validated predictions from each base learner, and the outcome will always be the true outcome, `y`.

```{r}
sl_fit <- glm(y ~ pred_a + pred_b + pred_c, data = obs_preds)
kable(broom::tidy(sl_fit), digits=3, caption = "Metalearner regression coefficients") 
```

This metalearner provides us with the coefficients, or weights, to apply to each of the base learners. In other words, if we have a set of predictions from Learner A, B, and C, we can obtain our best possible predictions by starting with an intercept of `r round(sl_fit$coefficients[1],3)`, then adding `r round(sl_fit$coefficients[[2]],3)` $\times$ predictions from Learner A, `r round(sl_fit$coefficients[[3]],3)` $\times$ predictions from Learner B, and `r round(sl_fit$coefficients[[4]],3)` $\times$ predictions from Learner C.

*For manual computation of the loss function (MSE), code for NNLS as a metalearner, and more information on choosing a metalearner, check out the [Appendix](#appendix).*

<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 6: Fit base learners on entire data set</h1></strong>
</body>
</html>

![](/img/sl_steps/step6.png){width=50%}

After we fit the metalearner, we officially have our superlearner algorithm, so it's time to input data and obtain predictions! To implement the algorithm and obtain final predictions, we first need to fit the base learners on the full data set.

```{r}
fit_a <- glm(y ~ x2 + x4, data=obs)
fit_b <- glm(y ~ x1 + x2 + x1*x3 + sin(x4), data=obs)
fit_c <- glm(y ~ x1*x2*x3, data=obs)
```


<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 7: Obtain predictions from each base learner on entire data set</h1></strong>
</body>
</html>

![](/img/sl_steps/step7.png){width=40%}

We'll use *those* base learner fits to get predictions from each of the base learners for the entire data set, and then we will plug those predictions into the metalearner fit. Remember, we were previously using cross-validated predictions, rather than fitting the base learners on the whole data set. This was to avoid overfitting.

```{r}
pred_a <- predict(fit_a)
pred_b <- predict(fit_b)
pred_c <- predict(fit_c)
full_data_preds <- tibble(pred_a, pred_b, pred_c)
```


<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 8: Use metalearner fit to weight base learners</h1></strong>
</body>
</html>

![](/img/sl_steps/step8.png){width=60%}

Once we have the predictions from the full data set, we can input them to the metalearner, where the output will be a final prediction for `y`.

```{r}
sl_predictions <- predict(sl_fit, newdata = full_data_preds)
kable(head(sl_predictions), col.names = "sl_predictions", digits= 2, caption = "Final SL predictions (manual)") 
```

And... that's it! Those are our superlearner predictions.


<html>
<body>
<h2 style="color:#c30a0a"><strong>Step 9 and beyond...</h1></strong>
</body>
</html>

We could compute the MSE of the ensemble superlearner predictions.

```{r}
sl_mse <- mean((obs$y - sl_predictions)^2)
sl_mse
```

We could also add more algorithms to our base learner library (we definitely should, since we only used linear regressions!), and we could write functions to tune these algorithms' hyperparameters over various grids. For example, if we were to include random forest in our library, we may want to tune over a number of trees and maximum bucket sizes.

We can then cross-validate this entire process to evaluate the predictive performance of our superlearner algorithm. Alternatively, we could leave a hold-out training data set to evaluate the performance.

# Using the `SuperLearner` package

Alternatively, we could use the `SuperLearner` package and avoid all that hand-coding. Here is how you would specify an ensemble superlearner for our data with the base learner libraries of `ranger` (random forests), `glmnet` (LASSO, by default), and `earth` (MARS).

```{r, warning=F, message = F}
library(SuperLearner)
x_df <- obs %>% select(x1:x4) %>% as.data.frame()
sl_fit <- SuperLearner(Y = obs$y, X = x_df, family = gaussian(),
                     SL.library = c("SL.ranger", "SL.glmnet", "SL.earth"))
```

You can specify the metalearner with the `method` argument. The default is NNLS.

## CV-Risk and Coefficient Weights

We can examine the cross-validated `Risk` (loss function), and the `Coef`ficient (weight) given to each of the models.

```{r}
sl_fit
```

From this summary we can see that the CV-risk (the default risk is MSE) in this library of base learners is lowest for `SL.Earth`. This translates to the largest coefficient, or weight, given to the predictions from `earth` (which implements the MARS algorithm... but the name "MARS" is copyrighted!).

The LASSO model implemented by `glmnet` has the highest CV-risk, and after the metalearning step, those predictions receive a coefficient, or weight, of 0. This means that the predictions from LASSO will not be incorporated into the final predictions at all. 

## Obtaining the predictions

We can extract the predictions easily via the `SL.predict` element of the `SuperLearner` fit object.

```{r}
kable(head(sl_fit$SL.predict), digits=2, col.names = "sl_predictions", caption = "Final SL predictions (package)") 
```

## Cross-validated Superlearner

Recall that we can cross-validate the entire model fitting process to evaluate the predictive performance of our superlearner algorithm. This is easy with the function `CV.SuperLearner()`. Beware, this gets computationally burdensome very quickly!

```{r, eval=F}
cv_sl_fit <- CV.SuperLearner(Y = obs$y, X = x_df, family = gaussian(),
                     SL.library = c("SL.ranger", "SL.glmnet", "SL.earth"))
```

For more information on the `SuperLearner` package, take a look at this [vignette](https://cran.r-project.org/web/packages/SuperLearner/vignettes/Guide-to-SuperLearner.html).


## Alternative ways to superlearn

Other packages freely available in `R` that can be used to implement the superlearner algorithm include `sl3` (an update to the older `Superlearner` package), `h2o`, `ml3`, and `caretEnsemble`. I previously wrote a [very brief tutorial](https://www.khstats.com/blog/sl3_demo/sl/) on using `sl3` for an NYC R-Ladies demo.

Python aficionados might find this [blog post](https://machinelearningmastery.com/super-learner-ensemble-in-python/) useful. I have never performed superlearning in Python, but if I had to, I would probably try `h2o` first. H2o is available across in programming languages and their Chief Machine Learning Scientist, [Erin Ledell](https://twitter.com/ledell?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor), was an author of the original `SuperLearner` package.

# Coming soon... when prediction is not the end goal

Like most algorithms designed for prediction, the superlearner algorithm does not produce standard errors, making statistical inference such as confidence intervals and p-values impossible. When prediction is not the end goal, superlearning works well with semi-parametric estimation methods (for example, Targeted Maximum Likelihood Estimation (TMLE)) for statistical inference. This allows us to utilize flexible models and place minimal assumptions on the distribution of our data.

I made a similar [visual guide for TMLE](https://github.com/hoffmakl/CI-visual-guides/blob/master/visual-guides/TMLE.pdf). If you found this superlearning tutorial helpful, check back here later for another one on TMLE. Alternatively, you can find me on Medium: [\@kathoffman317](https://medium.com/@kathoffman317). If you're curious about TMLE in the meantime, I really like [this tutorial](https://migariane.github.io/TMLE.nb.html) by Miguel Angel Luque Fernandez.

<html>
   <head>
      <title>HTML Image as link</title>
   </head>
   <body>
      <a href="https://github.com/hoffmakl/CI-visual-guides/blob/master/visual-guides/TMLE.pdf">
         <img alt="cheatsheet" src="/img/TMLE.jpg"
         width=100%">
      </a>
   </body>
</html>


# Appendix

### Manually computing the MSE

Let's say we have chosen our loss function of interest to be the Mean Squared Error (MSE). We could first compute the squared error $(y - \hat{y})^2$ for each CV prediction A, B, and C.

```{r}
cv_sq_error <-
  obs_preds %>%
  mutate(cv_sqrd_error_a = (y-pred_a)^2,   # compute squared error for each observation
         cv_sqrd_error_b = (y-pred_b)^2,
         cv_sqrd_error_c = (y-pred_c)^2)
```

```{r, fig.width=5}
cv_sq_error %>% 
  pivot_longer(c(cv_sqrd_error_a, cv_sqrd_error_b, cv_sqrd_error_c), # make the CV squared errors long form for plotting
               names_to = "base_learner",
               values_to = "squared_error") %>%
  mutate(base_learner = toupper(str_remove(base_learner, "cv_sqrd_error_"))) %>%
  ggplot(aes(base_learner, squared_error, col=base_learner)) + # make box plots
  geom_boxplot() +
  theme_bw() +
  guides(col=F) +
  labs(x = "Base Learner", y="Squared Error", title="Squared Errors of Learner A, B, and C")
```

And then take the mean of those three cross-validated squared error columns, grouped by `cv_fold`, to get the CV-MSE for each fold.

```{r}
cv_risks <-
  cv_sq_error %>%
  group_by(cv_fold) %>%
  summarise(cv_mse_a = mean(cv_sqrd_error_a),
            cv_mse_b = mean(cv_sqrd_error_b),
            cv_mse_c = mean(cv_sqrd_error_c)
            )
cv_risks %>%
  pivot_longer(cv_mse_a:cv_mse_c,
               names_to = "base_learner",
               values_to = "mse") %>%
  mutate(base_learner = toupper(str_remove(base_learner,"cv_mse_")))  %>%
  ggplot(aes(cv_fold, mse, col=base_learner)) +
  geom_point() +
  theme_bw()  +
    scale_x_continuous(breaks = 1:10) +
  labs(x = "Cross-Validation (CV) Fold", y="Mean Squared Error (MSE)", col = "Base Learner", title="CV-MSEs for Base Learners A, B, and C")
```

We see that across each fold, Learner B consistently has an MSE around 0.02, while Learner C hovers around 0.1, and Learner A varies between 0.35 and .45. We can take another mean to get the overall CV-MSE for each learner.

```{r}
cv_risks %>%
  select(-cv_fold) %>%
  summarise_all(mean) %>%
  kable(digits=2, caption = "CV-MSE for each base learner") %>%
  kable_styling(position = "center")
```

The base learner that performs the best using our chosen loss function of interest is clearly Learner B. We can see from our data simulation code why this is true -- Learner B is almost exactly the mimicking the data generating mechanism of `y`.

Our results align with the linear regression fit from our metalearning step; Learner B predictions received a much larger coefficient relative to Learners A and C.

### Discrete Superlearner

We *could* stop after minimizing our loss function (MSE) and fit Learner B to our full data set, and that would be called using the **discrete superlearner**.

```{r}
discrete_sl_predictions <- predict(glm(y ~ x1 + x2 + x1*x3 + sin(x4), data=obs))
```

However, we can almost always create an even better prediction algorithm if we use information from *all* of the algorithms' CV predictions.

### Choosing a metalearner

The advice from Erin Ledell in her dissertation, *Scalable Ensemble Learning and Computationally Efficient Variance Estimation*, on choosing a metalearner is:

>"Since the set of predictions from the various base learners may be highly correlated, it is advisable to choose a metalearning method that performs well in the presence of collinear predictors.  Regularization via Ridge or Lasso regression is commonly used to over-come the issue of collinearity among the predictor variables that make up the level-one dataset."

Here, the level-one data-set refers to the cross-validated predictions from Step 4. She goes on to discuss how several statisticians (Leo Breiman, Michael LeBlanc, Robert Tibshirani) concluded empirically that the lowest prediction errors were obtained using non-negative least squares regression (NNLS).

Whatever metalearner we choose is simply a tool to minimize a loss function of interest (in these examples, MSE).  Although the metalearning algorithm is often some sort of regularized linear model, a variety of parametric and non-parametric methods can used as a metalearner. For more information, I recommend reading Ledell's [disseration](https://escholarship.org/uc/item/3kb142r2).

### Code for NNLS

NNLS is simply a form of penalized regression that does not allow the coefficients to be negative. We could see what our weights would be if we had used NNLS as the metalearner in the linear regression example using the `nnls` package, which takes the arguments of `x`, a matrix of predictors, and `y`, an outcome vector.

```{r}
library(nnls)
nnls_fit <- nnls(cbind(pred_a, pred_b, pred_c), obs$y) # Fit NNLS with nnls::nnls()
nnls_raw_weights <- nnls_fit$x # obtain coefficients
```
We can normalize these coefficients so that they sum to 1 (so they're actually "weights") with the following code:

```{r}
weights <- nnls_raw_weights/sum(nnls_raw_weights)
round(weights, 3)
```

The NNLS metalearner for our step-by-step example with three linear regressions would thus give a weight of `r round(weights, 3)[2]` to Learner B and `r round(weights, 3)[3]`, and no weight to the predictions from Learner A.

### Another visual guide

The steps of the superlearner algorithm are summarized nicely in this graphic in Chapter 3 of the *Targeted Learning* book:

![](/img/sl_diagram.png)

# References

Polley, Eric. “Chapter 3: Superlearning.” Targeted Learning: Causal Inference for Observational and Experimental Data, by M. J. van der. Laan and Sherri Rose, Springer, 2011.

Polley E, LeDell E, Kennedy C, van der Laan M. Super Learner: Super Learner Prediction. 2016 URL https://CRAN.R-project.org/package=SuperLearner. R package version 2.0-22.

Naimi AI, Balzer LB. Stacked generalization: an introduction to super learning. *Eur J Epidemiol.* 2018;33(5):459-464. doi:10.1007/s10654-018-0390-z

LeDell, E. (2015). Scalable Ensemble Learning and Computationally Efficient Variance Estimation. UC Berkeley. ProQuest ID: LeDell_berkeley_0028E_15235. Merritt ID: ark:/13030/m5wt1xp7. Retrieved from https://escholarship.org/uc/item/3kb142r2

# Session Info

```{r}
sessionInfo()
```
